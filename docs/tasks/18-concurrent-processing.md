# Task 18: 並行処理

## 概要
画像最適化、HTML解析、テキスト圧縮などCPUバウンドな処理に並行処理を導入し、変換パフォーマンスを向上させる。

## 関連
- **spec.md参照**: §5.4
- **依存タスク**: Task 10（PalmDoc圧縮）, Task 16（画像最適化）
- **GitHub Issue**: —

## 背景
大容量EPUB（100MB+）の変換パフォーマンスを向上させるため、独立して処理できるタスクを並行実行する。Goのgoroutineとチャネルを活用し、CPUマルチコアを効率的に利用する。

## 実装場所
- 各パッケージの既存ファイルを更新
- テストファイル: 各パッケージの既存テストに並行テストを追加

## 要件

### 並行化対象

#### 1. 画像最適化（最も効果的）
- 各画像を独立して処理（相互依存なし）
- ワーカープールパターン
- CPU数に応じた並行度（`runtime.NumCPU()`）

#### 2. HTMLファイルの解析
- 各XHTMLファイルを並行して読み込み・パース
- 最終的にスパイン順で結合

#### 3. テキスト圧縮
- 各テキストレコード（4096バイトブロック）を並行圧縮
- 圧縮後のレコードは元の順序を維持

### 同期が必要な処理
- OPF解析（他の処理の前提）
- レコード番号の割り当て（順序依存）
- ファイル書き込み（競合回避）

### 実装パターン: ワーカープール
- 入力チャネル: 処理対象（画像データ、テキストブロック）
- 出力チャネル: 処理結果
- ワーカー数: `runtime.NumCPU()` またはユーザー指定
- エラー伝播: `errgroup` パッケージを使用

## データ構造

### WorkerPool
- Workers: int — ワーカー数
- Process: func(input) (output, error) — 処理関数
- Results: 順序付き結果（indexで管理）

## 実装ガイドライン
- `sync.WaitGroup` と `golang.org/x/sync/errgroup` を活用
- チャネルバッファサイズ: ワーカー数の2倍
- 画像処理: 入力をインデックス付きで分配、結果をインデックスで並べ替え
- テキスト圧縮: 同様にインデックスで順序管理
- メモリ管理: 大量の画像を同時にメモリに展開しないよう、ワーカープールで制御
- エラー時: `errgroup` でキャンセルを伝播

### パフォーマンス目標
- 10MBのEPUB: 5秒以内
- 100MBのEPUB: 30秒以内
- CPU使用率: 画像処理で > 50%

## テスト方針
- 並行処理の結果が逐次処理と一致すること
- 画像処理の並行実行（複数画像）
- テキスト圧縮の並行実行（複数ブロック）
- ワーカー数1（逐次実行と同等）の正常動作
- エラー発生時のキャンセル伝播
- ベンチマークテスト（逐次 vs 並行の比較）

## 完了条件
- [ ] ワーカープールの汎用実装
- [ ] 画像最適化の並行化
- [ ] テキスト圧縮の並行化
- [ ] エラー伝播とキャンセル
- [ ] ベンチマークテスト
- [ ] 全テストがパス
