# Task 06: AZW3ファイルアセンブリ

## 概要
PDBヘッダー、レコードリスト、全レコードデータを統合してAZW3ファイルとして書き出す。レコード番号とオフセットの整合性を保証する。

## 関連
- **spec.md参照**: §6.7
- **依存タスク**: Task 01（MOBIヘッダー）, Task 02（EXTH）, Task 03（テキストレコード）, Task 04（FLIS/FCIS/EOF）, Task 05（FDST）
- **GitHub Issue**: #8

## 背景
AZW3ファイル生成の最終段階。個別に生成されたレコードを正しい順序で配置し、PDBヘッダーのレコードリストにオフセットを記録し、バイナリファイルとして出力する。

## 実装場所
- 新規ファイル: `internal/mobi/writer.go`
- テストファイル: `internal/mobi/writer_test.go`

## 要件

### レコード配置順序
1. レコード0: MOBIヘッダー + EXTHレコード + Full Name
2. レコード1〜N: テキストレコード
3. レコードN+1〜M: 画像レコード（Phase 2で追加）
4. NCXレコード（Task 14で追加される場合）
5. FDSTレコード
6. FLISレコード
7. FCISレコード
8. End-of-fileレコード

### レコード構築手順
1. レコードリストを初期化
2. レコード0を構築（Task 01 + Task 02）
3. テキストレコードを追加（Task 03）
4. 画像レコードを追加（Phase 2で実装）
5. NCXレコードを追加（Task 14、存在する場合）
6. FDSTレコードを追加（Task 05）
7. FLISレコードを追加（Task 04）
8. FCISレコードを追加（Task 04）
9. EOFレコードを追加（Task 04）
10. 各レコードのサイズを計算し、PDBヘッダーにレコード数を設定
11. レコード番号とオフセットを計算
12. MOBIヘッダー内のレコード番号参照を更新（FLIS, FCIS, FDST, 最初/最後のコンテンツ）
13. EXTHレコード121/125の値を最終レコード配置に合わせて確定（Task 02と連携）
14. PDBヘッダー + レコードリスト + 全レコードデータをファイルに書き込み

### オフセット計算
```
最初のレコードオフセット = 78 + (8 × レコード数) + 2
各レコードのオフセット = 前レコードのオフセット + 前レコードのサイズ
```

### 書き込み手順
1. 全レコードを先に構築してサイズを確定
2. PDBの `NewPDB()` にレコードサイズのスライスを渡す
3. PDBヘッダーバイト列を書き込み
4. レコードリストバイト列を書き込み
5. 各レコードのデータを順序通りに書き込み

## データ構造

### AZW3Writer 構造体
- Title: string — 書籍タイトル
- TextRecords: [][]byte — テキストレコード
- ImageRecords: [][]byte — 画像レコード（Phase 2）
- Metadata: メタデータ情報
- 各種レコード番号のフィールド

## 実装ガイドライン
- 既存の `mobi.PDB`（`NewPDB`, `HeaderBytes`, `RecordListBytes`）を活用
- `io.Writer` インターフェースに書き込み（ファイルやバッファに対応）
- レコード番号の相互参照を2パスで解決:
  1. 第1パス: 全レコードを構築してサイズとレコード番号を確定
  2. 第2パス: MOBIヘッダー内のレコード番号参照を更新して再構築
- バイナリ書き込みは全てビッグエンディアン

## テスト方針
- 最小構成（テキスト1レコード、画像なし）でAZW3が生成できること
- PDBヘッダーの Type="BOOK", Creator="MOBI" であること
- レコード数が正しいこと
- 各レコードのオフセットが正しいこと
- MOBIヘッダー内のFLIS/FCISレコード番号が正しいこと
- 生成されたファイルがバイナリ的に整合していること

## 完了条件
- [x] AZW3Writer構造体と初期化関数
- [x] レコード配置とオフセット計算
- [x] MOBIヘッダー内レコード番号参照の更新
- [x] io.Writer への書き込み関数
- [x] 最小構成での統合テスト
- [x] 全テストがパス
